import numpy as np
import matplotlib.pyplot as plt
from scipy.io import wavfile
import os

# Configuration
INPUT_FILE = "demo_assets/part1/damaged_random.wav"  # Generated by main5_UNet_mask_2.py
OUTPUT_DIR = "demo_assets/part1"
os.makedirs(OUTPUT_DIR, exist_ok=True)

def save_spectrogram(audio, sr, save_name):
    """Save spectrogram with consistent style"""
    plt.figure(figsize=(10, 4))
    plt.specgram(audio, NFFT=1024, Fs=sr, noverlap=512, cmap='inferno')
    plt.axis('off')
    plt.tight_layout(pad=0)
    plt.savefig(os.path.join(OUTPUT_DIR, save_name), bbox_inches='tight', pad_inches=0)
    plt.close()
    print(f"ğŸ–¼ï¸  Spectrogram saved: {save_name}")

def save_wav(audio, sr, save_name):
    """Save audio file"""
    path = os.path.join(OUTPUT_DIR, save_name)
    audio = np.clip(audio, -1.0, 1.0)
    wavfile.write(path, sr, (audio * 32767).astype(np.int16))
    print(f"ğŸ’¾ Audio saved: {save_name}")

def linear_interpolation_restoration():
    """
    Apply linear interpolation to restore damaged audio.
    Detects gaps (zero or near-zero regions) and fills them using np.interp.
    """
    print("=" * 60)
    print("ğŸ”§ Linear Interpolation Audio Restoration")
    print("=" * 60)
    
    # 1. Load damaged audio
    if not os.path.exists(INPUT_FILE):
        print(f"âŒ Error: Input file not found: {INPUT_FILE}")
        print("ğŸ’¡ Please run main5_UNet_mask_2.py first to generate the damaged audio.")
        return
    
    sr, data = wavfile.read(INPUT_FILE)
    if len(data.shape) > 1:
        data = data.mean(axis=1)  # Convert to mono
    data = data.astype(np.float32) / np.max(np.abs(data))
    print(f"ğŸ“‚ Loaded: {INPUT_FILE}")
    print(f"   Sample rate: {sr} Hz, Duration: {len(data)/sr:.2f}s")
    
    # 2. Detect mask (identify damaged regions)
    # Assume damaged regions are near-zero (threshold = 1e-4)
    threshold = 1e-4
    mask = np.abs(data) > threshold  # True = valid, False = damaged
    
    num_damaged = np.sum(~mask)
    damage_ratio = num_damaged / len(data) * 100
    print(f"ğŸ” Detected {num_damaged} damaged samples ({damage_ratio:.2f}%)")
    
    if num_damaged == 0:
        print("âš ï¸  No damaged regions detected. Saving original as output.")
        save_wav(data, sr, "fixed_linear_random.wav")
        save_spectrogram(data, sr, "spec_linear_random.png")
        return
    
    # 3. Linear interpolation restoration
    # Core logic: Use np.interp to fill all gaps at once
    print("ğŸ“ Applying linear interpolation...")
    x_all = np.arange(len(data))
    x_valid = x_all[mask]      # x coordinates of known points
    y_valid = data[mask]       # y values of known points
    
    # Interpolate at damaged positions
    linear_fixed = data.copy()
    # interp(x to predict, known x, known y)
    linear_fixed[~mask] = np.interp(x_all[~mask], x_valid, y_valid)
    
    print("âœ… Interpolation complete!")
    
    # 4. Save results
    save_wav(linear_fixed, sr, "fixed_linear_random.wav")
    save_spectrogram(linear_fixed, sr, "spec_linear_random.png")
    
    print("=" * 60)
    print("ğŸ‰ Linear interpolation restoration complete!")
    print(f"ğŸ“ Output directory: {OUTPUT_DIR}")
    print("=" * 60)

if __name__ == "__main__":
    linear_interpolation_restoration()

